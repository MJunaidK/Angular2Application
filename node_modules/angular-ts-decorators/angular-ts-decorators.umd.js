(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('angular'), require('tslib'), require('reflect-metadata')) :
	typeof define === 'function' && define.amd ? define(['exports', 'angular', 'tslib', 'reflect-metadata'], factory) :
	(factory((global['angular-ts-decorators'] = global['angular-ts-decorators'] || {}),global.angular,global.tslib));
}(this, (function (exports,angular,tslib_1) { 'use strict';

var platformBrowserDynamic = function () { return PlatformRef; };
var PlatformRef = /** @class */ (function () {
    function PlatformRef() {
    }
    PlatformRef.bootstrapModule = function (moduleType, compilerOptions) {
        var moduleName = typeof moduleType === 'string' ? moduleType : moduleType.module.name;
        var strictDi = (compilerOptions.strictDi === true);
        angular.element(document).ready(function () {
            angular.bootstrap('body', [moduleName], { strictDi: strictDi });
        });
    };
    return PlatformRef;
}());

/** @internal */
var Declarations;
(function (Declarations) {
    Declarations[Declarations["component"] = 0] = "component";
    Declarations[Declarations["directive"] = 1] = "directive";
    Declarations[Declarations["pipe"] = 2] = "pipe";
})(Declarations || (Declarations = {}));
/** @internal */
var metadataKeys = {
    declaration: 'custom:declaration',
    name: 'custom:name',
    bindings: 'custom:bindings',
    options: 'custom:options',
    listeners: 'custom:listeners',
};
/** @internal */
function kebabToCamel(input) {
    return input.replace(/(-\w)/g, function (m) { return m[1].toUpperCase(); });
}
/** @internal */
function camelToKebab(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
/** @internal */
function getAttributeName(selector) {
    return selector.substr(1, selector.length - 2);
}
/** @internal */
function isAttributeSelector(selector) {
    return /^[\[].*[\]]$/g.test(selector);
}
/** @internal */
function getMetadata(metadataKey, target) {
    return Reflect.getMetadata(metadataKey, target);
}
/** @internal */
function defineMetadata(metadataKey, metadataValue, target) {
    Reflect.defineMetadata(metadataKey, metadataValue, target);
}
function getTypeName(target) {
    return getMetadata(metadataKeys.name, target);
}

/**
 * @internal
 * @desc Mapping between angular and angularjs LifecycleHooks
 */
var ngLifecycleHooksMap = {
    ngOnInit: '$onInit',
    ngOnDestroy: '$onDestroy',
    ngDoCheck: '$doCheck',
    ngOnChanges: '$onChanges',
    ngAfterViewInit: '$postLink'
};

function Component(_a) {
    var selector = _a.selector, options = tslib_1.__rest(_a, ["selector"]);
    return function (ctrl) {
        options.controller = ctrl;
        var isAttrSelector = isAttributeSelector(selector);
        var bindings = getMetadata(metadataKeys.bindings, ctrl);
        if (bindings) {
            if (isAttrSelector) {
                options['bindToController'] = bindings;
                options['controllerAs'] = options['controllerAs'] || '$ctrl';
            }
            else
                options['bindings'] = bindings;
        }
        if (isAttrSelector) {
            options.restrict = 'A';
        }
        replaceLifecycleHooks(ctrl);
        var selectorName = isAttrSelector ? getAttributeName(selector) : selector;
        defineMetadata(metadataKeys.name, kebabToCamel(selectorName), ctrl);
        defineMetadata(metadataKeys.declaration, isAttrSelector ? Declarations.directive : Declarations.component, ctrl);
        defineMetadata(metadataKeys.options, options, ctrl);
    };
}
/** @internal */
function registerComponent(module, component) {
    var name = getMetadata(metadataKeys.name, component);
    var options = getMetadata(metadataKeys.options, component);
    var listeners = getMetadata(metadataKeys.listeners, options.controller);
    if (listeners) {
        options.controller = extendWithHostListeners(options.controller, listeners);
    }
    module.component(name, options);
}
/** @internal */
function extendWithHostListeners(ctrl, listeners) {
    var handlers = Object.keys(listeners);
    var namespace = '.HostListener';
    var NewCtrl = /** @class */ (function (_super) {
        tslib_1.__extends(NewCtrl, _super);
        function NewCtrl($element) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _this = _super.apply(this, args) || this;
            _this.$element = $element;
            return _this;
        }
        NewCtrl.prototype.$postLink = function () {
            var _this = this;
            if (_super.prototype.$postLink) {
                _super.prototype.$postLink.call(this);
            }
            handlers.forEach(function (handler) {
                var eventName = listeners[handler].eventName;
                _this.$element.on(eventName + namespace, _this[handler].bind(_this));
            });
        };
        NewCtrl.prototype.$onDestroy = function () {
            if (_super.prototype.$onDestroy) {
                _super.prototype.$onDestroy.call(this);
            }
            this.$element.off(namespace);
        };
        return NewCtrl;
    }(ctrl));
    NewCtrl.$inject = ['$element'].concat(ctrl.$inject || []);
    return NewCtrl;
}
/** @internal */
function replaceLifecycleHooks(ctrl) {
    var ctrlClass = ctrl.prototype;
    var ngHooksFound = getHooksOnCtrlClass(ctrlClass);
    ngHooksFound.forEach(function (ngHook) {
        var angularJsHook = ngLifecycleHooksMap[ngHook];
        ctrlClass[angularJsHook] = ctrlClass[ngHook];
        delete ctrlClass[ngHook];
    });
}
/** @internal */
function getHooksOnCtrlClass(ctrlClass) {
    return Object.keys(ngLifecycleHooksMap)
        .filter(function (hook) { return angular.isFunction(ctrlClass[hook]); });
}

function Directive(_a) {
    var selector = _a.selector, options = tslib_1.__rest(_a, ["selector"]);
    return function (ctrl) {
        var bindings = getMetadata(metadataKeys.bindings, ctrl);
        if (bindings) {
            options.bindToController = bindings;
        }
        options.restrict = options.restrict || 'A';
        var selectorName = isAttributeSelector(selector) ? getAttributeName(selector) : selector;
        defineMetadata(metadataKeys.name, kebabToCamel(selectorName), ctrl);
        defineMetadata(metadataKeys.declaration, Declarations.directive, ctrl);
        defineMetadata(metadataKeys.options, options, ctrl);
    };
}
/** @internal */
function registerDirective(module, ctrl) {
    var directiveFunc;
    var name = getMetadata(metadataKeys.name, ctrl);
    var options = getMetadata(metadataKeys.options, ctrl);
    replaceLifecycleHooks(ctrl);
    var listeners = getMetadata(metadataKeys.listeners, ctrl);
    options.controller = listeners ? extendWithHostListeners(ctrl, listeners) : ctrl;
    directiveFunc = function () { return options; };
    module.directive(name, directiveFunc);
}

function Injectable(name) {
    return function (Class) {
        if (name) {
            defineMetadata(metadataKeys.name, name, Class);
        }
    };
}
/** @internal */
function registerProviders(module, providers) {
    providers.forEach(function (provider) {
        // providers registered using { provide, useClass/useFactory/useValue } syntax
        if (provider.provide) {
            var name_1 = provider.provide;
            if (provider.useClass && provider.useClass instanceof Function) {
                module.service(name_1, provider.useClass);
            }
            else if (provider.useFactory && provider.useFactory instanceof Function) {
                provider.useFactory.$inject = provider.deps || provider.useFactory.$inject;
                module.factory(name_1, provider.useFactory);
            }
            else if (provider.useValue) {
                module.constant(name_1, provider.useValue);
            }
        }
        else {
            var name_2 = getMetadata(metadataKeys.name, provider);
            if (!name_2) {
                console.error(provider.name + " was not registered as angular service:\n        Provide explicit name in @Injectable when using class syntax or register it using object provider syntax:\n        { provide: '" + provider.name + "', useClass: " + provider.name + " }");
            }
            else {
                module.service(name_2, provider);
            }
        }
    });
}

function Pipe(options) {
    return function (Class) {
        defineMetadata(metadataKeys.name, options.name, Class);
        defineMetadata(metadataKeys.declaration, Declarations.pipe, Class);
    };
}
/** @internal */
function registerPipe(module, filter) {
    var name = getMetadata(metadataKeys.name, filter);
    var filterFactory = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var injector = args[0]; // reference to $injector
        var instance = injector.instantiate(filter);
        return instance.transform.bind(instance);
    };
    filterFactory.$inject = ['$injector'].concat(filter.$inject || []);
    module.filter(name, filterFactory);
}

function Input(alias) {
    return function (target, key) { return addBindingToMetadata(target, key, '<', alias); };
}
function Output(alias) {
    return function (target, key) { return addBindingToMetadata(target, key, '&', alias); };
}
/** @internal */
function addBindingToMetadata(target, key, direction, alias) {
    var targetConstructor = target.constructor;
    var bindings = getMetadata(metadataKeys.bindings, targetConstructor) || {};
    bindings[key] = alias || direction;
    defineMetadata(metadataKeys.bindings, bindings, targetConstructor);
}

function NgModule(_a) {
    var id = _a.id, _b = _a.bootstrap, bootstrap$$1 = _b === void 0 ? [] : _b, _c = _a.declarations, declarations = _c === void 0 ? [] : _c, _d = _a.imports, imports = _d === void 0 ? [] : _d, _e = _a.providers, providers = _e === void 0 ? [] : _e;
    return function (Class) {
        // module registration
        var deps = imports.map(function (mod) { return typeof mod === 'string' ? mod : mod.module.name; });
        if (!id) {
            console.warn('You are not providing ngModule id, be careful this code won\'t work when uglified.');
            id = Class.name;
        }
        var module = angular.module(id, deps);
        // components, directives and filters registration
        declarations.forEach(function (declaration) {
            var declarationType = getMetadata(metadataKeys.declaration, declaration);
            switch (declarationType) {
                case Declarations.component:
                    registerComponent(module, declaration);
                    break;
                case Declarations.directive:
                    registerDirective(module, declaration);
                    break;
                case Declarations.pipe:
                    registerPipe(module, declaration);
                    break;
                default:
                    console.error("Can't find type metadata on " + declaration.name + " declaration, did you forget to decorate it?\n            Decorate your declarations using @Component, @Directive or @Pipe decorator.");
            }
        });
        // services registration
        if (providers) {
            registerProviders(module, providers);
        }
        // config and run blocks registration
        var config = Class.config, run = Class.run;
        if (config) {
            module.config(config);
        }
        if (run) {
            module.run(run);
        }
        // add bootstrap elements to DOM
        bootstrap$$1.forEach(function (component) {
            module.run(insertComponentToDOM(component));
        });
        // expose angular module as static property
        Class.module = module;
    };
}
function insertComponentToDOM(component) {
    return function () {
        var componentName = getTypeName(component);
        var selector = camelToKebab(componentName);
        var $el = "<" + selector + "></" + selector + ">";
        angular.element('body').append($el);
    };
}

function HostListener(eventName, args) {
    return function (target, propertyKey, descriptor) {
        var listener = descriptor.value;
        if (typeof listener !== 'function') {
            throw new Error("@HostListener decorator can only be applied to methods not: " + typeof listener);
        }
        var targetConstructor = target.constructor;
        /**
         * listeners = { onMouseEnter: { eventName: 'mouseenter mouseover', args: [] } }
         */
        var listeners = getMetadata(metadataKeys.listeners, targetConstructor) || {};
        listeners[propertyKey] = { eventName: eventName, args: args };
        defineMetadata(metadataKeys.listeners, listeners, targetConstructor);
    };
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @whatItDoes Represents a type that a Component or other object is instances of.
 *
 * @description
 *
 * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
 * the `MyCustomComponent` constructor function.
 *
 * @stable
 */
var Type = Function;
function isType(v) {
    return typeof v === 'function';
}

exports.platformBrowserDynamic = platformBrowserDynamic;
exports.Component = Component;
exports.Directive = Directive;
exports.Injectable = Injectable;
exports.Pipe = Pipe;
exports.Input = Input;
exports.Output = Output;
exports.NgModule = NgModule;
exports.HostListener = HostListener;
exports.getTypeName = getTypeName;
exports.ngLifecycleHooksMap = ngLifecycleHooksMap;
exports.Type = Type;
exports.isType = isType;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=angular-ts-decorators.umd.js.map
